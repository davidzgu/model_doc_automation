from pathlib import Path
from langchain_core.messages import HumanMessage, SystemMessage, ToolMessage
from bsm_multi_agents.graph.state import WorkflowState
from bsm_multi_agents.config.llm_config import get_llm
from bsm_multi_agents.agents.mcp_adapter import (
    call_mcp_tool,
    list_mcp_tools_sync, 
    mcp_tool_to_langchain_tool
)

from bsm_multi_agents.agents.utils import extract_mcp_content




def pricing_calculator_agent_node(state: WorkflowState) -> WorkflowState:
    """
    LangGraph node: LLM planning / explanation step.
    Dynamically fetches tools from the MCP server and binds them to the LLM.
    """
    errors = state.get("errors", [])

    if "csv_file_path" not in state or not state["csv_file_path"]:
        errors.append("pricing_calculator_agent_node: csv_file_path is missing")
        state["errors"] = errors
        return state

    server_path = state.get("server_path")
    if not server_path:
        errors.append("pricing_calculator_agent_node: server_path is missing")
        state["errors"] = errors
        return state

    output_dir = state.get("output_dir")
    
    # 1. Discover MCP tools
    try:
        mcp_tools = list_mcp_tools_sync(server_path)
    except Exception as e:
        errors.append(f"pricing_calculator_agent_node: Failed to list MCP tools: {e}")
        state["errors"] = errors
        return state

    # 2. Convert to LangChain tools
    langchain_tools = [mcp_tool_to_langchain_tool(t, server_path) for t in mcp_tools]
    
    # 3. Bind tools to LLM
    llm = get_llm().bind_tools(langchain_tools)
    
    # 4. Construct Prompt
    # We give the LLM the context (files) and let it choose the tools.
    system_prompt = (
        "You are a quantitative calculator agent. "
        "You have access to tools specifically for Greeks calculation via an MCP server. "
        "Use the available tools to process the requested data. "
        "If you are confident, you can run all tools in parallel."
    )
    
    user_prompt = (
        f"Input CSV File: {state['csv_file_path']}\n"
        f"Output Directory: {output_dir}\n\n"
        "Please calculate the Greeks for the options in the input CSV file. "
        "Save the results to the output directory. "
        "Ensure you call the calculation tools."
    )

    messages = list(state.get("messages", []))
    messages.append(SystemMessage(content=system_prompt))
    messages.append(HumanMessage(content=user_prompt))
         
    
    # Invoke
    try:
        ai_msg = llm.invoke(messages)
        messages.append(ai_msg)
        state["messages"] = messages
    except Exception as e:
        errors.append(f"pricing_calculator_agent_node: LLM invocation failed: {e}")
    
    state["errors"] = errors
    return state


def pricing_calculator_tool_node(state: WorkflowState) -> WorkflowState:
    """
    Tool node: Executes tool calls generated by the agent.
    """
    errors = state.get("errors", [])
    messages = list(state.get("messages", []))
    
    if not messages:
        return state
        
    last_msg = messages[-1]
    if not hasattr(last_msg, "tool_calls") or not last_msg.tool_calls:
        return state
    
    server_path = state.get("server_path")
    if not server_path:
        errors.append("pricing_calculator_tool_node: server_path is missing")
        state["errors"] = errors
        return state

    # Ensure tool_outputs dict exists
    if "tool_outputs" not in state or state["tool_outputs"] is None:
         state["tool_outputs"] = {}

    tool_outputs_msgs = []
    
    for tool_call in last_msg.tool_calls:
        tool_name = tool_call["name"]
        args = tool_call["args"]
        call_id = tool_call["id"]
        
        
        try:
            # Execute logic
            raw_result = call_mcp_tool(tool_name, server_path, args)
            result_text = extract_mcp_content(raw_result)
            
            # Create ToolMessage
            tool_outputs_msgs.append(ToolMessage(content=result_text, tool_call_id=call_id, name=tool_name))
            
            # Generic Output Handling: Store by tool name
            state["greeks_results_path"] = result_text.strip()
            
                
        except Exception as e:
            err_msg = f"Error executing {tool_name}: {e}"
            errors.append(err_msg)
            tool_outputs_msgs.append(ToolMessage(content=err_msg, tool_call_id=call_id, is_error=True))
            
    messages.extend(tool_outputs_msgs)
    state["messages"] = messages
    state["errors"] = errors
    return state


if __name__ == "__main__":
    project_root = Path(__file__).resolve().parents[3]
    csv_file_path = str(project_root / "data/input/dummy_options.csv")
    output_dir = str(project_root / "data/cache")
    server_path = str(project_root / "src" / "bsm_multi_agents" / "mcp" / "server.py")
    
    state = WorkflowState(
        csv_file_path=csv_file_path, 
        output_dir=output_dir, 
        server_path=server_path,
        errors=[],
        messages=[]
    )
    
    print("--- Starting Agent Loop ---")
    for step in range(3):
        print(f"\nStep {step + 1}: Agent")
        state = pricing_calculator_agent_node(state)
        last_msg = state["messages"][-1]
        
        if not last_msg.tool_calls:
            print("Agent decided to stop (no tool calls).")
            break
            
        print(f"Tool calls: {len(last_msg.tool_calls)}")
        for tc in last_msg.tool_calls:
            print(f" - {tc['name']}")
        
        print(f"Step {step + 1}: Tool execution")
        state = pricing_calculator_tool_node(state)
        
    print("\n Final State Keys:", state.keys())
    if "bsm_results_path" in state:
        print("BSM Results Path:", state["bsm_results_path"])
    else:
        print("BSM Results Path MISSING")