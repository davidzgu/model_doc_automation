from pathlib import Path
import json
from typing import Dict, Any

from langchain_core.messages import HumanMessage, SystemMessage, ToolMessage 

from bsm_multi_agents.graph.state import WorkflowState
from bsm_multi_agents.config.llm_config import get_llm
from bsm_multi_agents.agents.mcp_adapter import call_mcp_tool
from bsm_multi_agents.agents.utils import extract_mcp_content, load_tools_from_mcp_and_local


def pricing_validator_agent_node(state: WorkflowState) -> WorkflowState:
    """
    LangGraph node: LLM planning / explanation step.
    Dynamically fetches tools from the MCP server and binds them to the LLM.
    """
    errors = state.get("errors", [])

    if "greeks_results_path" not in state or not state["greeks_results_path"]:
        errors.append("pricing_validator_agent_node: greeks_results_path is missing")
        state["errors"] = errors
        return state

    server_path = state.get("server_path")
    if not server_path:
        errors.append("pricing_validator_agent_node: server_path is missing")
        state["errors"] = errors
        return state

    output_dir = state.get("output_dir")
    
    local_tool_paths = state.get("local_tool_paths", [])
    langchain_tools = load_tools_from_mcp_and_local(server_path, local_tool_paths)
    
    llm = get_llm().bind_tools(langchain_tools)
    
    # We give the LLM the context (files) and let it choose the tools.
    system_prompt = (
        "You are a quantitative validator agent. "
        "You have access to tools specifically for validation of greeks via an MCP server. "
        "Use the available tools to process the requested data. "
    )
    
    user_prompt = (
        f"Input CSV File: {state['greeks_results_path']}\n"
        f"Output Directory: {output_dir}\n\n"
        "Please validate the Greeks for the options in the input CSV file. "
        "Save the results to the output directory. "
        "Ensure you call the validation tools."
    )

    messages = list(state.get("messages", []))
    messages.append(SystemMessage(content=system_prompt))
    messages.append(HumanMessage(content=user_prompt))
    
    # Invoke
    try:
        ai_msg = llm.invoke(messages)
        messages.append(ai_msg)
        state["messages"] = messages
    except Exception as e:
        errors.append(f"pricing_validator_agent_node: LLM invocation failed: {e}")
    
    state["errors"] = errors
    return state


def pricing_validator_tool_node(state: WorkflowState) -> WorkflowState:
    """
    Tool node: Executes tool calls generated by the agent.
    """
    errors = state.get("errors", [])
    messages = list(state.get("messages", []))
    
    if not messages:
        return state
        
    last_msg = messages[-1]
    if not hasattr(last_msg, "tool_calls") or not last_msg.tool_calls:
        return state
    
    server_path = state.get("server_path")
    if not server_path:
        errors.append("pricing_validator_tool_node: server_path is missing")
        state["errors"] = errors
        return state

    # Ensure tool_outputs dict exists
    if "tool_outputs" not in state or state["tool_outputs"] is None:
         state["tool_outputs"] = {} 

    tool_outputs_msgs = []
    
    for tool_call in last_msg.tool_calls:
        tool_name = tool_call["name"]
        args = tool_call["args"]
        call_id = tool_call["id"]
        
        try:
            # Execute logic
            raw_result = call_mcp_tool(tool_name, server_path, args)
            result_text = extract_mcp_content(raw_result)
            
            # Create ToolMessage
            tool_outputs_msgs.append(ToolMessage(content=result_text, tool_call_id=call_id, name=tool_name))
            
            # Generic Output Handling
            state["validate_results_path"] = result_text.strip()

        except Exception as e:
            err_msg = f"Error executing {tool_name}: {e}"
            errors.append(err_msg)
            tool_outputs_msgs.append(ToolMessage(content=err_msg, tool_call_id=call_id, is_error=True))
            
    messages.extend(tool_outputs_msgs)
    state["messages"] = messages
    state["errors"] = errors
    return state
