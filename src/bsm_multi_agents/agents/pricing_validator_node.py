from pathlib import Path
import json
from typing import Dict, Any

from langchain_core.messages import HumanMessage, SystemMessage, ToolMessage 

from bsm_multi_agents.graph.state import WorkflowState
from bsm_multi_agents.config.llm_config import get_llm
from bsm_multi_agents.agents.mcp_adapter import call_mcp_tool
from bsm_multi_agents.agents.utils import (
    extract_mcp_content, 
    load_tools_from_mcp_and_local,
    call_local_tool
)


def pricing_validator_agent_node(state: WorkflowState) -> WorkflowState:
    """
    LangGraph node: LLM planning / explanation step.
    Dynamically fetches tools from the MCP server and binds them to the LLM.
    """
    print("\n>>> [Pricing Validator Agent] Starting validation planning...")
    errors = state.get("errors", [])

    if "current_file_path" not in state or not state["current_file_path"]:
        errors.append("pricing_validator_agent_node: current_file_path is missing")
        state["errors"] = errors
        return state

    server_path = state.get("server_path")
    if not server_path:
        errors.append("pricing_validator_agent_node: server_path is missing")
        state["errors"] = errors
        return state

    output_dir = state.get("output_dir")
    
    local_tool_folder_path = state.get("local_tool_folder_path", None)
    langchain_tools = load_tools_from_mcp_and_local(server_path, local_tool_folder_path)
    # print(f">>> [Pricing Validator Agent] Loaded {len(langchain_tools)} tools: {[t.name for t in langchain_tools]}")
    
    llm = get_llm().bind_tools(langchain_tools)
    
    # We give the LLM the context (files) and let it choose the tools.
    system_prompt = (
        "You are a professional quantitative validator agent. "
        "Your goal is to validate option results by calling all relevant validation tools in parallel.\n\n"
        "Instructions:\n"
        "1. Analyze the input file path provided by the user.\n"
        "2. Directly call all three tools: 'verify_put_call_parity', 'run_sensitivity_analysis', and 'run_stress_analysis'.\n"
        "3. Generate all tool calls in a single turn for efficiency.\n"
        "4. **Argument Note**: For 'run_sensitivity_analysis' and 'run_stress_analysis', you MUST only provide the 'input_path' argument. Skip the 'scenarios' argument entirely to allow the functions to use their high-quality default values.\n"
        "5. You can provide a brief acknowledgement before naming the tools, but ensure the tool calls are correctly generated."
    )

    user_prompt = (
        f"The input CSV for validation is located at: {state['current_file_path']}\n\n"
        "Please run the following validation suite now:\n"
        "- verify_put_call_parity\n"
        "- run_sensitivity_analysis\n"
        "- run_stress_analysis"
        "do not set scenarios argument if not specified"
    )

    messages = list(state.get("messages", []))
    
    # 1. Inject Task (User Prompt) IF NOT returning from a ReAct tool loop.
    is_tool_return = (len(messages) > 0 and isinstance(messages[-1], ToolMessage))
    
    if not is_tool_return:
        # Clear previous agent's messages to avoid confusion
        messages = []
        messages.append(HumanMessage(content=user_prompt))

    # 2. Prepend System Prompt (Ephemeral)
    invocation_messages = [SystemMessage(content=system_prompt)] + messages
    

    
    # Invoke
    try:
        ai_msg = llm.invoke(invocation_messages)
        # Check if ai_msg is empty
        if hasattr(ai_msg, 'tool_calls') and ai_msg.tool_calls:
            print(f">>> [Pricing Validator Agent] Decide to use tools: {[tool['name'] for tool in ai_msg.tool_calls]}")
            
        if not ai_msg.content and (not hasattr(ai_msg, 'tool_calls') or not ai_msg.tool_calls):
             print(">>> [Pricing Validator Agent] WARNING: LLM returned an empty response!")
        
        messages.append(ai_msg)
        state["messages"] = messages
    except Exception as e:
        errors.append(f"pricing_validator_agent_node: LLM invocation failed: {e}")
    
    state["errors"] = errors
    return state


def pricing_validator_tool_node(state: WorkflowState) -> WorkflowState:
    """
    Tool node: Executes tool calls generated by the agent.
    """
    print("\n>>> [Pricing Validator Tool] Executing validation calls...")
    errors = state.get("errors", [])
    messages = list(state.get("messages", []))
    
    if not messages:
        return state
        
    last_msg = messages[-1]
    if not hasattr(last_msg, "tool_calls") or not last_msg.tool_calls:
        return state
    
    server_path = state.get("server_path")
    if not server_path:
        errors.append("pricing_validator_tool_node: server_path is missing")
        state["errors"] = errors
        return state

    # Ensure tool_outputs dict exists
    if "tool_outputs" not in state or state["tool_outputs"] is None:
         state["tool_outputs"] = {} 

    tool_outputs_msgs = []
    
    for tool_call in last_msg.tool_calls:
        tool_name = tool_call["name"]
        args = tool_call["args"]
        call_id = tool_call["id"]
        print(f">>> [Pricing Validator Tool] Executing tool calls: {tool_name}")
        
        try:
            # 1. Try Local Tool First
            local_tool_paths = state.get("local_tool_paths", [])
            try:
                raw_result = call_local_tool(tool_name, args=args, local_tool_paths=local_tool_paths)
                result_text = str(raw_result)
            except LookupError:
                # 2. Fallback to MCP Tool
                # print(f"Tool {tool_name} not found locally, trying MCP...")
                raw_result = call_mcp_tool(tool_name, server_path, args)
                result_text = extract_mcp_content(raw_result)
            
            # Create ToolMessage
            tool_outputs_msgs.append(ToolMessage(content=result_text, tool_call_id=call_id, name=tool_name))
            
            # Generic Output Handling
            state["current_file_path"] = result_text.strip()

        except Exception as e:
            err_msg = f"Error executing {tool_name}: {e}"
            errors.append(err_msg)
            tool_outputs_msgs.append(ToolMessage(content=err_msg, tool_call_id=call_id, is_error=True))
            
    messages.extend(tool_outputs_msgs)
    state["messages"] = messages
    state["errors"] = errors
    return state


if __name__ == "__main__":
    from bsm_multi_agents.agents.pricing_calculator_node import (
        pricing_calculator_agent_node,
        pricing_calculator_tool_node,
    )

    project_root = Path(__file__).resolve().parents[3]
    csv_file_path = str(project_root / "data/input/dummy_options.csv")
    output_dir = str(project_root / "data/cache")
    server_path = str(project_root / "src" / "bsm_multi_agents" / "mcp" / "server.py")
    local_tool_paths = [os.path.join(project_root, "src/bsm_multi_agents/tools/my_add.py")]
    
    state = WorkflowState(
        csv_file_path=csv_file_path, 
        output_dir=output_dir, 
        server_path=server_path,
        local_tool_paths=local_tool_paths,
        errors=[],
        messages=[]
    )
    
    state = pricing_calculator_agent_node(state)
    state = pricing_calculator_tool_node(state)
    state = pricing_validator_agent_node(state)
    state = pricing_validator_tool_node(state)
    
    print(state)